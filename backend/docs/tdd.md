## **프로젝트 개발 및 테스트 헌법**

### **제1장: 우리가 테스트하는 이유 (Why We Test)**

1.  **핵심 목표**: 우리의 목표는 코드 커버리지가 아닌 **'신뢰도(Confidence)'**다. 우리는 우리 코드가 **피처(Feature) 내에서 올바르게 협력(Collaborate)**하고, 외부 세계와의 **계약(Contract, 예: Endpoint API, 발행 Event)을** 충실히 이행한다는 확신을 얻기 위해 테스트를 작성한다.
2.  **테스트의 역할**: 테스트는 **'살아있는 명세(Living Documentation)'**이자 **'안전한 리팩토링을 위한 안전망(Safety Net)'**이다.

### **제2장: 전략의 구성과 정의 (The Structure & Definitions of Our Strategy)**

1.  **공식 모델**: 우리는 Spotify Engineering의 **허니콤 모델(Honeycomb Model)**을 채택한다. 이는 **'통합 테스트'에 압도적인 비중(80%)을 두어** 최고의 신뢰도를 얻는 전략이다. (참고: [Spotify Engineering](https://engineering.atspotify.com/2018/01/testing-of-microservices))

2.  **테스트 피라미드 구조**:
```
┌─────────────────────────────────────────┐
│   E2E (거의 작성하지 않음)                │  ← 통합 테스트로 검증 불가능한 경우만
│   "실제 배포 환경에서의 핵심 여정"         │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│   통합 테스트 (80%, 우리의 핵심)          │
│   ─────────────────────────────────────  │
│   • Event-Driven Integration Tests      │  ← 가장 중요!
│     "UseCase → Event 발행 → Listener    │
│      → 최종 결과 검증"                   │
│                                         │
│   비즈니스 로직 + 이벤트 흐름 전체 검증   │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│   API 테스트 (10~15%)                   │
│   "HTTP 레이어만 검증"                   │
│   • 요청/응답 직렬화                     │
│   • HTTP 상태 코드                      │
│   • 예외 핸들링                         │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│   단위 테스트 (5~10%)                   │  ← 복잡한 도메인 로직만
│   • 비밀번호 검증 로직                   │
│   • 할인 계산 로직                       │
│   • 복잡한 알고리즘                      │
└─────────────────────────────────────────┘
```

3.  **테스트 계층과 정의**:

| 테스트 계층                           | 정의 및 책임 범위                                                                                                      | 비중 및 작성 시점                                             |
| :------------------------------------ | :--------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------ |
| **통합 테스트 (Integration Test)**    | **(우리의 핵심 전략, 80%)** `usecase`를 호출하여 비즈니스 로직 + Event 발행 + Listener 동작까지 전체 협력을 검증.    | **가장 많이 작성**. TDD의 RED 단계부터 시작.                  |
| **API 테스트 (API Test)**             | **(10~15%)** `MockMvc`로 HTTP 레이어만 검증. 요청/응답 직렬화, 상태 코드, 예외 핸들링에 집중. 비즈니스 로직은 제외. | **통합 테스트 완료 후** 웹 계층만 검증할 때 추가.             |
| **단위 테스트 (Unit Test)**           | **(5~10%, 선택적)** `model` 패키지의 복잡한 도메인 로직만 격리 테스트. 예: 비밀번호 검증, 할인 계산 로직.           | **복잡한 알고리즘이 있을 때만** 리팩토링 단계에서 추가.       |
| **E2E 테스트 (End-to-End Test)**      | **(거의 작성하지 않음)** 통합 테스트로 검증할 수 없는 실제 배포 환경의 핵심 여정만 검증.                              | **통합 테스트로 불충분할 때만** 예외적으로 작성.              |

### **제3장: 개발 절차 (Our Development Workflow)**

우리의 TDD 사이클은 비즈니스 로직의 핵심부터 시작하여 외부 인터페이스로 확장하는 방식으로 진행된다.

1.  **1단계: 실패하는 통합 테스트 작성 (RED - Integration Test)**
    - 모든 기능 개발은 **Event-Driven 통합 테스트**를 작성하는 것으로 시작한다.
    - `usecase` 호출 → Event 발행 → Listener 동작 → 최종 결과까지 검증하는 테스트를 작성한다.
    - 예: "회원가입 → UserRegisteredEvent 발행 → 이메일 발송까지" 전체 플로우

2.  **2단계: 빠르게 성공시키기 (GREEN)**
    - 테스트를 통과시킬 가장 단순한 코드를 `usecase`, `model`, `adapter`, `event`, `listener`에 작성한다.
    - Event 발행과 Listener 구현을 포함한다.

3.  **3단계: 리팩토링 (REFACTOR)**
    - 통합 테스트의 보호 아래, 코드와 테스트의 설계를 개선한다.
    - 복잡한 도메인 로직이 발견되면 **단위 테스트**를 추가한다.

4.  **4단계: API 테스트 추가 (VERIFY - API Layer Only)**
    - 통합 테스트 완료 후, **HTTP 레이어만 검증하는 API 테스트**를 추가한다.
    - 검증 대상: 요청/응답 직렬화, HTTP 상태 코드, 예외 핸들링
    - **비즈니스 로직은 검증하지 않는다** (이미 통합 테스트에서 검증됨)

### **제4장: 도구와 경계 (Our Tools & Boundaries)**

#### **4.1절: 협력 검증을 위한 도구**

우리가 작성한 코드들이 서로 올바르게 협력하는지 검증하는 것을 최우선으로 하며, 이를 위해 다음 도구들을 사용한다.

- `Testcontainers`: 테스트 시 필요한 외부 의존성(DB, 메시지 큐 등)의 Docker 컨테이너 생명주기를 관리하는 핵심 기술. 예를 들어, **LocalStack 컨테이너를 실행하여 AWS 서비스 연동을 테스트**하는 데 사용한다.
- `MockMvc`: 엔드포인트 테스트 시 HTTP 요청/응답을 시뮬레이션한다.

#### **4.2절: 격리를 위한 도구**

특정 상황에서 테스트 대상을 외부 요인으로부터 격리하여 집중적으로 검증해야 할 때, 다음과 같은 도구를 제한적으로 사용한다.

- `Mock` 프레임워크 (Mockito, @MockBean):
  - **허용 Case (외부 서비스 격리)**: 우리가 제어할 수 없는 서드파티 서비스(예: 결제 API, 외부 이메일 서비스, SMS 발송 서비스)와의 연동 지점을 격리할 때.
    - **통합 테스트에서도 외부 서비스는 Mock 허용**: 통합 테스트는 우리 시스템 내부의 협력을 검증하는 것이 목적이므로, 외부 서드파티 서비스는 `@MockBean`으로 격리하여 테스트한다.
    - 예시: `EmailSender` 인터페이스를 `@MockBean`으로 Mock하여 실제 이메일 발송 없이 테스트
  - **금지 사항**:
    - DB Repository와 같이 우리가 직접 제어하고 검증할 수 있는 내부 컴포넌트를 Mocking하는 행위는 엄격히 금지한다.
    - 통합 테스트에서 내부 컴포넌트(UseCase, Listener, 내부 Service 등)를 Mock하는 행위는 금지한다.
    - 내부 협력 과정(UseCase → Event → Listener)을 Mock으로 대체하는 행위는 금지한다.

#### **4.3절: 테스트 작성 원칙**

1. **통합 테스트 우선**: 항상 통합 테스트부터 작성한다. 이것이 우리의 핵심 전략이다.
2. **중복 검증 금지**: 통합 테스트에서 검증한 비즈니스 로직을 API 테스트에서 다시 검증하지 않는다.
3. **API 테스트는 HTTP 레이어만**: API 테스트는 요청/응답 형식, 상태 코드, 직렬화만 검증한다.
4. **단위 테스트는 선택적**: 복잡한 도메인 로직(예: 비밀번호 검증, 할인 계산)이 있을 때만 추가한다.
5. **E2E는 최소화**: 통합 테스트로 충분하지 않은 경우에만 예외적으로 작성한다.

#### **4.4절: DisplayName과 메서드명 작성 규칙**

**핵심 원칙**: 테스트 실패 메시지를 보는 사람이 코드를 안 봐도 무엇이 잘못되었는지 이해할 수 있어야 한다.

**1. 통합 테스트 (Integration Test) - 비즈니스 시나리오를 서술**

- **DisplayName**: 긴 문장 OK, "~하면 ~하고 ~한다" 연결, 실제 사용자 관점
- **메서드명**: 간략하게 핵심만 (예: `successfulRegistration`, `duplicateEmailFails`)
- **예시**:
  ```java
  @DisplayName("사용자가 회원가입하면 계정이 생성되고 비밀번호가 암호화되어 저장되며 인증 토큰이 발급되고 인증 이메일이 발송된다")
  void successfulRegistration()

  @DisplayName("비밀번호가 8자 미만이거나 영문자와 숫자를 포함하지 않으면 InvalidPasswordException이 발생한다")
  void invalidPasswordFails()

  @DisplayName("이미 가입된 이메일로 회원가입하면 DuplicateEmailException이 발생한다")
  void duplicateEmailFails()
  ```

**2. 단위 테스트 (Unit Test) - 구체적인 입력과 출력 명시**

- **DisplayName**: 짧고 명확, 엣지 케이스 명시, 기술적 용어 사용 OK
- **메서드명**: 간략하게 (예: `tooShortPassword`, `missingLetters`)
- **예시**:
  ```java
  @DisplayName("비밀번호가 8자 미만이면 false를 반환한다")
  void tooShortPassword()

  @DisplayName("비밀번호가 영문자를 포함하지 않으면 false를 반환한다")
  void missingLetters()

  @DisplayName("비밀번호가 숫자를 포함하지 않으면 false를 반환한다")
  void missingDigits()
  ```

**3. API 테스트 (Controller Test) - HTTP 관점으로 작성**

- **DisplayName**: HTTP 메서드, 경로, 상태 코드 포함, REST API 명세처럼
- **메서드명**: 간략하게 (예: `createUserSuccess`, `invalidPasswordReturns400`)
- **예시**:
  ```java
  @DisplayName("POST /api/users - 유효한 요청이면 201 Created와 사용자 정보를 반환한다")
  void createUserSuccess()

  @DisplayName("POST /api/users - 비밀번호 검증 실패 시 400 Bad Request와 ProblemDetail을 반환한다")
  void invalidPasswordReturns400()

  @DisplayName("POST /api/users - 중복 이메일이면 409 Conflict와 ProblemDetail을 반환한다")
  void duplicateEmailReturns409()
  ```

**4. 공통 규칙**

- **DisplayName**: 한국어로 상세하게, 비즈니스 관점에서 서술
- **메서드명**: 영어로 간략하게 (camelCase), 핵심만 표현
- **예외 클래스명**: DisplayName에서 정확히 명시 (예: `InvalidPasswordException`)
- **금지사항**:
  - DisplayName에서 "테스트한다", "검증한다" 같은 불필요한 서술 금지
  - 애매한 표현 금지 (예: "올바르게 동작한다" → 구체적으로!)
  - 메서드명에서 test 접두사 금지 (예: `testRegister` ❌, `successfulRegistration` ✅)

### **제5장: AI의 역할과 책임 (AI's Role and Responsibilities)**

1.  **역할**: 너는 이 프로젝트의 AI 개발 어시스턴트로서, 선임 소프트웨어 엔지니어의 역할을 수행한다.

2.  **최고 권한 (Highest Authority)**: 사용자가 제공한 이 문서(와 다른 모든 문서)는 너의 최고 권위를 가진다. 이 문서들의 규칙과 원칙은 너의 사전 지식이나 일반적인 외부의 모범 사례와 충돌할 경우, **반드시 우선 적용되어야 한다.**

3.  **책임**:
    - 너는 사용자의 모든 요청을 제공된 규칙에 따라 해석하고, 그 규칙을 준수하는 코드와 설명만을 제공할 책임이 있다.
    - 항상 **KISS(Keep It Simple, Stupid) 원칙**에 따라, 불필요하게 복잡하지 않고 가장 명확한 코드를 생성해야 한다.
    - 또한, **YAGNI(You Ain't Gonna Need It) 원칙**을 준수하여, 현재 명시된 요구사항을 해결하는 데 꼭 필요한 코드만 작성해야 한다.
    - 규칙에 위배되는 요청에 대해서는, 해당 규칙을 근거로 정중하게 대안을 제시해야 한다.
